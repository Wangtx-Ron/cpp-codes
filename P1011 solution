大佬原文：

//-----------------------------------------------------------------------------------//
一道小学生都会做的数学题。。。
看了几篇题解，感觉写得都有点长啊，其实远没那么麻烦。
没抓住此题的精髓——
首先我们可以把上下车的人数列一个表格，把第二站上车的人数设为b：

车站	第一站	第二站	第三站	第四站	第五站	第六站	第七站	第八站
上车	a	b	a+b	a+2b	2a+3b	3a+5b	5a+8b	……
下车	0	b	b	a+b	a+2b	2a+3b	3a+5b	……
1，1，2，3，5，8……								
发现了什么？

不就是斐波那契数列吗？
那么我们就可以求出一个站上上车的人数（分别有几个a和b）

由于第一站和第二站a没有连续增加，从第三站才开始连续加，所以一个站上上车的a的系数就是f[第几站-2]。

由于b从第二站就开始连续加了，所以一个站上上车的b的系数就是f[第几站-1];

所以一个站上上车的人数就是f[第几站-2]*a+f[第几站-1]*b;

通过观察表格可知，每一站上还有的人，除这一站上车的人，第一站上车的a人和第二站下车的b人，其余都可以消掉。（自己去看看就知道了）所以在每个站上还有的人数就是：(f[第几站-2]+1)*a+([第几站-1]-1)*b

m实质上就是上一站还有的人，最关键的方程就列出来了：

m=f[n-1-2]*a+f[n-1-1]*b+a-b
化简得：

b=(m-(f[n-3]+1)*a)/(f[n-2]-1)
再把算出来的b带到第x站就行啦！代码很简洁：

#include<bits/stdc++.h>
using namespace std;
int a,n,m,x,b,f[20];
int main(){
    scanf("%d%d%d%d",&a,&n,&m,&x);
    f[1]=1;
    for(int _=2;_<=n-1;f[_]=f[_-1]+f[_-2],_++);
    b=(m-(f[n-3]+1)*a)/(f[n-2]-1);
    cout<<(f[x-2]+1)*a+(f[x-1]-1)*b<<endl;
    return 0;
}
//-----------------------------------------------------------------------------------//

ykuouzf大佬的题解
思路比较好理解
重点在于推出每站人数的公式(f[第几站-2]+1)*a+([第几站-1]-1)*b
重点在两个括号内的+1和-1
从头看，归根结底所有的影响都源于第1、2站，其余均被抵消
发现一开始的a影响持续多一个，又发现b总是下车的比原有的多一个，要从上车里减
所以有了
